%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{rkd Documentation}
\date{Aug 14, 2019}
\release{0.1.0}
\author{IRO}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


rkd is a Python library for kinematic analysis of robots

Source code: \sphinxurl{https://github.com/iro-upgto/rkd}


\chapter{Contents}
\label{\detokenize{index:welcome-to-rkd-s-documentation}}\label{\detokenize{index:contents}}

\section{Didactic}
\label{\detokenize{_src/didactic:didactic}}\label{\detokenize{_src/didactic:module-rkd.didactic}}\label{\detokenize{_src/didactic::doc}}\index{rkd.didactic (module)}
Universidad Politécnica de Guanajuato
Departamento de Ingeniería Robótica, (c) 2019

This module has been designed for academic purposes, using SymPy as base library. 
It’s easy to check that SymPy is slower than NumPy specially in matrix algebra, 
however SymPy is more convenient to use as didactic tool due to the given facilities 
as the symbolic manipulation, calculation of partial and ordinary derivatives, 
matricial multiplication using asterisk symbol, “init\_printing” function and so on.


\subsection{core}
\label{\detokenize{_src/didactic:core}}\label{\detokenize{_src/didactic:module-rkd.didactic.core}}\index{rkd.didactic.core (module)}\index{Robot (class in rkd.didactic.core)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.Robot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{rkd.didactic.core.}}\sphinxbfcode{\sphinxupquote{Robot}}}{\emph{*args}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Define a robot-serial-arm given the Denavit-Hartenberg parameters 
and joint type, as tuples:
\index{J (rkd.didactic.core.Robot attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.Robot.J}}\pysigline{\sphinxbfcode{\sphinxupquote{J}}}
Geometric Jacobian matrix

\end{fulllineitems}

\index{J\_i() (rkd.didactic.core.Robot method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.Robot.J_i}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{J\_i}}}{\emph{i}}{}
Geometric Jacobian matrix

\end{fulllineitems}

\index{T (rkd.didactic.core.Robot attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.Robot.T}}\pysigline{\sphinxbfcode{\sphinxupquote{T}}}
T\_n\textasciicircum{}0 
Homogeneous transformation matrix of N-Frame respect to Base-Frame

\end{fulllineitems}

\index{p() (rkd.didactic.core.Robot method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.Robot.p}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{p}}}{\emph{i}}{}
Position for every i-Frame wrt 0-Frame

\end{fulllineitems}

\index{plot\_workspace() (rkd.didactic.core.Robot method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.Robot.plot_workspace}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_workspace}}}{}{}
TODO

\end{fulllineitems}

\index{z() (rkd.didactic.core.Robot method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.Robot.z}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{z}}}{\emph{i}}{}
z-dir of every i-Frame wrt 0-Frame

\end{fulllineitems}


\end{fulllineitems}

\index{RigidBody2D (class in rkd.didactic.core)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.RigidBody2D}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{rkd.didactic.core.}}\sphinxbfcode{\sphinxupquote{RigidBody2D}}}{\emph{points}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Defines a rigid body through a series of points that 
make it up.
\index{draw() (rkd.didactic.core.RigidBody2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.RigidBody2D.draw}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{draw}}}{\emph{color='r'}, \emph{kaxis=None}}{}
Dibuja el cuerpo rígido en sus estatus actual

\end{fulllineitems}

\index{move() (rkd.didactic.core.RigidBody2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.RigidBody2D.move}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{move}}}{\emph{q}}{}
Traslada el cuerpo rígido un vector q

\end{fulllineitems}

\index{rotate() (rkd.didactic.core.RigidBody2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.RigidBody2D.rotate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rotate}}}{\emph{angle}}{}
Rota el cuerpo rígido un ángulo determinado alrededor 
del eje coordenado z.

\end{fulllineitems}

\index{scale() (rkd.didactic.core.RigidBody2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.core.RigidBody2D.scale}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scale}}}{\emph{sf}}{}
Escala el cuerpo rígido

\end{fulllineitems}


\end{fulllineitems}



\subsection{transformations}
\label{\detokenize{_src/didactic:transformations}}\label{\detokenize{_src/didactic:module-rkd.didactic.transformations}}\index{rkd.didactic.transformations (module)}\index{axa2rot() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.axa2rot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{axa2rot}}}{\emph{k}, \emph{theta}}{}
Given a R\textasciicircum{}3 vector (k) and an angle (theta), return 
the SO(3) matrix associated.

\end{fulllineitems}

\index{compose\_rotations() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.compose_rotations}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{compose\_rotations}}}{\emph{*rotations}}{}
Composes rotation matrices w.r.t. fixed or movable frames
\begin{description}
\item[{rotations}] \leavevmode{[}tuple{]}
A tuple that contains (angle, axis, frame, deg)

\end{description}
\begin{description}
\item[{R}] \leavevmode{[}\sphinxcode{\sphinxupquote{sympy.matrices.dense.MutableDenseMatrix}}{]}
Rotation matrix

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{compose\PYGZus{}rotations}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fixed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{local}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{⎡0.707106781186548  \PYGZhy{}0.612372435695794  0.353553390593274 ⎤}
\PYG{g+go}{⎢                                                         ⎥}
\PYG{g+go}{⎢0.707106781186547  0.612372435695795   \PYGZhy{}0.353553390593274⎥}
\PYG{g+go}{⎢                                                         ⎥}
\PYG{g+go}{⎣        0                 0.5          0.866025403784439 ⎦}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{dh() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.dh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{dh}}}{\emph{a}, \emph{alpha}, \emph{d}, \emph{theta}}{}
Calculates Denavit-Hartenberg matrix given the four parameters.
\begin{description}
\item[{a}] \leavevmode{[}int, float or symbol{]}
DH parameter

\item[{alpha}] \leavevmode{[}int, float or symbol{]}
DH parrameter

\item[{d}] \leavevmode{[}int, float or symbol{]}
DH parameter

\item[{theta}] \leavevmode{[}int, float or symbol{]}
DH parameter

\end{description}
\begin{description}
\item[{H}] \leavevmode{[}\sphinxcode{\sphinxupquote{sympy.matrices.dense.MutableDenseMatrix}}{]}
Denavit-Hartenberg matrix (4x4)

\end{description}

With numerical values:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dh}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{⎡0  0  1   0 ⎤}
\PYG{g+go}{⎢            ⎥}
\PYG{g+go}{⎢1  0  0  100⎥}
\PYG{g+go}{⎢            ⎥}
\PYG{g+go}{⎢0  1  0  50 ⎥}
\PYG{g+go}{⎢            ⎥}
\PYG{g+go}{⎣0  0  0   1 ⎦}
\end{sphinxVerbatim}

Using symbolic values:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{t}\PYG{p}{)}
\PYG{g+go}{⎡cos(t)  \PYGZhy{}sin(t)  0  a⋅cos(t)⎤}
\PYG{g+go}{⎢                            ⎥}
\PYG{g+go}{⎢sin(t)  cos(t)   0  a⋅sin(t)⎥}
\PYG{g+go}{⎢                            ⎥}
\PYG{g+go}{⎢  0        0     1     0    ⎥}
\PYG{g+go}{⎢                            ⎥}
\PYG{g+go}{⎣  0        0     0     1    ⎦}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{eul2htm() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.eul2htm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{eul2htm}}}{\emph{phi}, \emph{theta}, \emph{psi}, \emph{seq='zxz'}, \emph{deg=False}}{}
Given a set of Euler Angles (phi,theta,psi) for specific 
sequence this function returns the homogeneous transformation 
matrix associated. Default sequence is ZXZ.
\begin{description}
\item[{phi}] \leavevmode{[}int,float,symbol{]}
phi angle

\item[{theta}] \leavevmode{[}int,float,symbol{]}
theta angle

\item[{psi}] \leavevmode{[}int,float,symbol{]}
psi angle

\item[{seq}] \leavevmode{[}str{]}
Rotation sequence

\item[{deg}] \leavevmode{[}bool{]}
True if (phi,theta,psi) are given in degrees

\end{description}
\begin{description}
\item[{H}] \leavevmode{[}\sphinxcode{\sphinxupquote{sympy.matrices.dense.MutableDenseMatrix}}{]}
Homogeneous transformation matrix

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eul2htm}\PYG{p}{(}\PYG{l+m+mi}{90}\PYG{p}{,}\PYG{l+m+mi}{90}\PYG{p}{,}\PYG{l+m+mi}{90}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{zxz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{⎡0  0   1  0⎤}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎢0  \PYGZhy{}1  0  0⎥}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎢1  0   0  0⎥}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎣0  0   0  1⎦}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eul2htm}\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{⎡0  0   1  0⎤}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎢0  \PYGZhy{}1  0  0⎥}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎢1  0   0  0⎥}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎣0  0   0  1⎦}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eul2htm}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{zyz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{⎡0   0  1  0⎤}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎢0   1  0  0⎥}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎢\PYGZhy{}1  0  0  0⎥}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎣0   0  0  1⎦}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{htm2eul() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.htm2eul}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{htm2eul}}}{\emph{H}, \emph{seq='zxz'}, \emph{deg=False}}{}
Given a homogeneous transformation matrix this function 
return the equivalent set of Euler Angles.

If “deg” is True then Euler Angles are converted to degrees.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{H} \PYG{o}{=} \PYG{n}{htmrot}\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{*}\PYG{n}{htmrot}\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{H}
\PYG{g+go}{⎡      √6   √6    ⎤}
\PYG{g+go}{⎢1/2   ──   ──   0⎥}
\PYG{g+go}{⎢      4    4     ⎥}
\PYG{g+go}{⎢                 ⎥}
\PYG{g+go}{⎢      √2  \PYGZhy{}√2    ⎥}
\PYG{g+go}{⎢ 0    ──  ────  0⎥}
\PYG{g+go}{⎢      2    2     ⎥}
\PYG{g+go}{⎢                 ⎥}
\PYG{g+go}{⎢\PYGZhy{}√3   √2   √2    ⎥}
\PYG{g+go}{⎢────  ──   ──   0⎥}
\PYG{g+go}{⎢ 2    4    4     ⎥}
\PYG{g+go}{⎢                 ⎥}
\PYG{g+go}{⎣ 0    0    0    1⎦}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{htm2eul}\PYG{p}{(}\PYG{n}{H}\PYG{p}{)}
\PYG{g+go}{⎛    ⎛√3⎞                     ⎞}
\PYG{g+go}{⎜atan⎜──⎟, atan(√7), \PYGZhy{}atan(√6)⎟}
\PYG{g+go}{⎝    ⎝2 ⎠                     ⎠}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{htm2eul}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{n}{deg}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{(40.8933946491309, 69.2951889453646, \PYGZhy{}67.7923457014035)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{htmrot() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.htmrot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{htmrot}}}{\emph{theta}, \emph{axis='z'}, \emph{deg=False}}{}
Return a homogeneous transformation matrix that represents a 
rotation “theta” about “axis”.
\begin{description}
\item[{theta}] \leavevmode{[}float, int or \sphinxtitleref{symbolic}{]}
Rotation angle (given in radians by default)

\item[{axis}] \leavevmode{[}str{]}
Rotation axis

\item[{deg}] \leavevmode{[}bool{]}
¿Is theta given in degrees?

\end{description}
\begin{description}
\item[{H}] \leavevmode{[}\sphinxcode{\sphinxupquote{sympy.matrices.dense.MutableDenseMatrix}}{]}
Homogeneous transformation matrix

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{htmrot}\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{⎡0  \PYGZhy{}1  0  0⎤}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎢1  0   0  0⎥}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎢0  0   1  0⎥}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎣0  0   0  1⎦}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{htmrot}\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{⎡1  0  0   0⎤}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎢0  0  \PYGZhy{}1  0⎥}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎢0  1  0   0⎥}
\PYG{g+go}{⎢           ⎥}
\PYG{g+go}{⎣0  0  0   1⎦}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{htmrot}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{⎡0.866025403784439  0         0.5         0⎤}
\PYG{g+go}{⎢                                          ⎥}
\PYG{g+go}{⎢        0          1          0          0⎥}
\PYG{g+go}{⎢                                          ⎥}
\PYG{g+go}{⎢      \PYGZhy{}0.5         0  0.866025403784439  0⎥}
\PYG{g+go}{⎢                                          ⎥}
\PYG{g+go}{⎣        0          0          0          1⎦}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{htmrot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{⎡1    0        0     0⎤}
\PYG{g+go}{⎢                     ⎥}
\PYG{g+go}{⎢0  cos(t)  \PYGZhy{}sin(t)  0⎥}
\PYG{g+go}{⎢                     ⎥}
\PYG{g+go}{⎢0  sin(t)  cos(t)   0⎥}
\PYG{g+go}{⎢                     ⎥}
\PYG{g+go}{⎣0    0        0     1⎦}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{htmtra() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.htmtra}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{htmtra}}}{\emph{d}}{}
Calculate the homogeneous transformation matrix of a translation
\begin{description}
\item[{d}] \leavevmode{[}list, tuple{]}
Translation vector

\end{description}
\begin{description}
\item[{H}] \leavevmode{[}\sphinxcode{\sphinxupquote{sympy.matrices.dense.MutableDenseMatrix}}{]}
Homogeneous transformation matrix

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{htmtra}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{⎡1  0  0   50 ⎤}
\PYG{g+go}{⎢             ⎥}
\PYG{g+go}{⎢0  1  0  \PYGZhy{}100⎥}
\PYG{g+go}{⎢             ⎥}
\PYG{g+go}{⎢0  0  1   30 ⎥}
\PYG{g+go}{⎢             ⎥}
\PYG{g+go}{⎣0  0  0   1  ⎦}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a,b,c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{htmtra}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{⎡1  0  0  a⎤}
\PYG{g+go}{⎢          ⎥}
\PYG{g+go}{⎢0  1  0  b⎥}
\PYG{g+go}{⎢          ⎥}
\PYG{g+go}{⎢0  0  1  c⎥}
\PYG{g+go}{⎢          ⎥}
\PYG{g+go}{⎣0  0  0  1⎦}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{rot2axa() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.rot2axa}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{rot2axa}}}{\emph{R}, \emph{deg=False}}{}
Given a SO(3) matrix return the axis-angle representation

\end{fulllineitems}

\index{rotx() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.rotx}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{rotx}}}{\emph{theta}, \emph{deg=False}}{}
Calculates the rotation matrix about the x-axis
\begin{description}
\item[{theta}] \leavevmode{[}float, int or \sphinxtitleref{symbolic}{]}
Rotation angle (given in radians by default)

\item[{deg}] \leavevmode{[}bool{]}
¿Is theta given in degrees?

\end{description}
\begin{description}
\item[{R}] \leavevmode{[}\sphinxtitleref{sympy.matrices.dense.MutableDenseMatrix}{]}
Rotation matrix (SO3)

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rotx}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{)}
\PYG{g+go}{⎡1  0   0 ⎤}
\PYG{g+go}{⎢         ⎥}
\PYG{g+go}{⎢0  \PYGZhy{}1  0 ⎥}
\PYG{g+go}{⎢         ⎥}
\PYG{g+go}{⎣0  0   \PYGZhy{}1⎦}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rotx}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{,} \PYG{n}{deg}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{⎡1          0                  0         ⎤}
\PYG{g+go}{⎢                                        ⎥}
\PYG{g+go}{⎢0         0.5         \PYGZhy{}0.866025403784439⎥}
\PYG{g+go}{⎢                                        ⎥}
\PYG{g+go}{⎣0  0.866025403784439         0.5        ⎦}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{roty() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.roty}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{roty}}}{\emph{theta}, \emph{deg=False}}{}
Calculates the rotation matrix about the y-axis
\begin{description}
\item[{theta}] \leavevmode{[}float, int or \sphinxtitleref{symbolic}{]}
Rotation angle (given in radians by default)

\item[{deg}] \leavevmode{[}bool{]}
¿Is theta given in degrees?

\end{description}
\begin{description}
\item[{R}] \leavevmode{[}\sphinxtitleref{sympy.matrices.dense.MutableDenseMatrix}{]}
Rotation matrix (SO3)

\end{description}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{roty}\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{⎡         √3 ⎤}
\PYG{g+go}{⎢1/2   0  ── ⎥}
\PYG{g+go}{⎢         2  ⎥}
\PYG{g+go}{⎢            ⎥}
\PYG{g+go}{⎢ 0    1   0 ⎥}
\PYG{g+go}{⎢            ⎥}
\PYG{g+go}{⎢\PYGZhy{}√3         ⎥}
\PYG{g+go}{⎢────  0  1/2⎥}
\PYG{g+go}{⎣ 2          ⎦}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{roty}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{deg}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{⎡0.866025403784439  0         0.5       ⎤}
\PYG{g+go}{⎢                                       ⎥}
\PYG{g+go}{⎢        0          1          0        ⎥}
\PYG{g+go}{⎢                                       ⎥}
\PYG{g+go}{⎣      \PYGZhy{}0.5         0  0.866025403784439⎦}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{rotz() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.rotz}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{rotz}}}{\emph{theta}, \emph{deg=False}}{}
Calculates the rotation matrix about the z-axis
\begin{description}
\item[{theta}] \leavevmode{[}float, int or \sphinxtitleref{symbolic}{]}
Rotation angle (given in radians by default)

\item[{deg}] \leavevmode{[}bool{]}
¿Is theta given in degrees?, False is default value

\end{description}
\begin{description}
\item[{R}] \leavevmode{[}\sphinxtitleref{sympy.matrices.dense.MutableDenseMatrix}{]}
Rotation matrix (SO3)

Examples

\end{description}

Using angle in radians,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rotz}\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{⎡0  \PYGZhy{}1  0⎤}
\PYG{g+go}{⎢        ⎥}
\PYG{g+go}{⎢1  0   0⎥}
\PYG{g+go}{⎢        ⎥}
\PYG{g+go}{⎣0  0   1⎦}
\end{sphinxVerbatim}

Or symbolic variables,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rotz}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{⎡cos(x)  \PYGZhy{}sin(x)  0⎤}
\PYG{g+go}{⎢                  ⎥}
\PYG{g+go}{⎢sin(x)  cos(x)   0⎥}
\PYG{g+go}{⎢                  ⎥}
\PYG{g+go}{⎣  0        0     1⎦}
\end{sphinxVerbatim}

Using angles in degrees,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rotz}\PYG{p}{(}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{deg}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{⎡0.707106781186548  \PYGZhy{}0.707106781186547  0⎤}
\PYG{g+go}{⎢                                        ⎥}
\PYG{g+go}{⎢0.707106781186547  0.707106781186548   0⎥}
\PYG{g+go}{⎢                                        ⎥}
\PYG{g+go}{⎣        0                  0           1⎦}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{skew() (in module rkd.didactic.transformations)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.transformations.skew}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.transformations.}}\sphinxbfcode{\sphinxupquote{skew}}}{\emph{u}}{}
Return skew-symmetric matrix associated to u vector

\end{fulllineitems}



\subsection{plotting}
\label{\detokenize{_src/didactic:plotting}}\phantomsection\label{\detokenize{_src/didactic:module-rkd.didactic.plotting}}\index{rkd.didactic.plotting (module)}

\subsection{util}
\label{\detokenize{_src/didactic:util}}\label{\detokenize{_src/didactic:module-rkd.didactic.util}}\index{rkd.didactic.util (module)}\index{deg2rad() (in module rkd.didactic.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.util.deg2rad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.util.}}\sphinxbfcode{\sphinxupquote{deg2rad}}}{\emph{theta}, \emph{evalf=True}}{}
Convert degrees to radians

theta : float, int, symbolic

theta\_rad : symbolic

\end{fulllineitems}

\index{ishtm() (in module rkd.didactic.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.util.ishtm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.util.}}\sphinxbfcode{\sphinxupquote{ishtm}}}{\emph{H}}{}
Is H a homogeneous transformation matrix ?

\end{fulllineitems}

\index{isorthonormal() (in module rkd.didactic.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.util.isorthonormal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.util.}}\sphinxbfcode{\sphinxupquote{isorthonormal}}}{\emph{R}}{}
Check if R is orthonormal

R : \sphinxtitleref{sympy.matrices.dense.MutableDenseMatrix}

False or True

\end{fulllineitems}

\index{isrot() (in module rkd.didactic.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.util.isrot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.util.}}\sphinxbfcode{\sphinxupquote{isrot}}}{\emph{R}}{}
Is R a rotation matrix ?

R : \sphinxtitleref{sympy.matrices.dense.MutableDenseMatrix}

False or True

\end{fulllineitems}

\index{rad2deg() (in module rkd.didactic.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.util.rad2deg}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.util.}}\sphinxbfcode{\sphinxupquote{rad2deg}}}{\emph{theta}, \emph{evalf=True}}{}
Convert radians to degrees

theta : float, int, symbolic

theta\_deg : symbolic

\end{fulllineitems}

\index{sympy2float() (in module rkd.didactic.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.util.sympy2float}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.util.}}\sphinxbfcode{\sphinxupquote{sympy2float}}}{\emph{sympy\_object}}{}
Convert a SymPy object to float object

\end{fulllineitems}

\index{sympy\_matrix\_to\_numpy\_float() (in module rkd.didactic.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.util.sympy_matrix_to_numpy_float}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.util.}}\sphinxbfcode{\sphinxupquote{sympy\_matrix\_to\_numpy\_float}}}{\emph{H}}{}
Convert SymPy Matrix (numerical) to NumPy array

H : \sphinxtitleref{sympy.matrices.dense.MutableDenseMatrix}

Hf : array

\end{fulllineitems}

\index{issympyobject() (in module rkd.didactic.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_src/didactic:rkd.didactic.util.issympyobject}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{rkd.didactic.util.}}\sphinxbfcode{\sphinxupquote{issympyobject}}}{\emph{obj}}{}
Determine if input (obj) is a sympy object.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k}{import} \PYG{n}{symbols}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{issympyobject}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{r}
\item {\sphinxstyleindexentry{rkd.didactic}}\sphinxstyleindexpageref{_src/didactic:\detokenize{module-rkd.didactic}}
\item {\sphinxstyleindexentry{rkd.didactic.core}}\sphinxstyleindexpageref{_src/didactic:\detokenize{module-rkd.didactic.core}}
\item {\sphinxstyleindexentry{rkd.didactic.plotting}}\sphinxstyleindexpageref{_src/didactic:\detokenize{module-rkd.didactic.plotting}}
\item {\sphinxstyleindexentry{rkd.didactic.transformations}}\sphinxstyleindexpageref{_src/didactic:\detokenize{module-rkd.didactic.transformations}}
\item {\sphinxstyleindexentry{rkd.didactic.util}}\sphinxstyleindexpageref{_src/didactic:\detokenize{module-rkd.didactic.util}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}